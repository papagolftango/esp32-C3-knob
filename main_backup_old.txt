#include <Arduino.h>
#include <TFT_eSPI.h>
#include <lvgl.h>
#include <WiFi.h>
#include <WiFiManager.h>
#include <PubSubClient.h>
#include <Wire.h>
// #include "ui.h"  // Uncomment this when you export from SquareLine Studio

// Haptic Feedback Configuration (DRV2605 Vibration Motor Driver)
#define DRV2605_ADDR     0x5A    // I2C address for DRV2605
#define DRV2605_STATUS   0x00
#define DRV2605_MODE     0x01
#define DRV2605_RTPIN    0x02
#define DRV2605_LIBRARY  0x03
#define DRV2605_WAVESEQ1 0x04
#define DRV2605_WAVESEQ2 0x05
#define DRV2605_WAVESEQ3 0x06
#define DRV2605_WAVESEQ4 0x07
#define DRV2605_WAVESEQ5 0x08
#define DRV2605_WAVESEQ6 0x09
#define DRV2605_WAVESEQ7 0x0A
#define DRV2605_WAVESEQ8 0x0B
#define DRV2605_GO       0x0C
#define DRV2605_OVERDRIVE 0x0D
#define DRV2605_SUSTAIN  0x0E
#define DRV2605_BRAKE    0x0F
#define DRV2605_AUDIOCTRL 0x10

// Haptic effect definitions
enum HapticEffect {
    HAPTIC_CLICK_STRONG = 1,      // Strong click (screen change)
    HAPTIC_CLICK_MEDIUM = 10,     // Medium click (encoder step)
    HAPTIC_CLICK_LIGHT = 14,      // Light click (touch)
    HAPTIC_BUZZ_SHORT = 17,       // Short buzz (notification)
    HAPTIC_PULSE_SHARP = 47,      // Sharp pulse (peak reached)
    HAPTIC_DOUBLE_CLICK = 2,      // Double click (confirmation)
    HAPTIC_ERROR = 36             // Error vibration
};

bool haptic_enabled = true;  // Global haptic enable/disable

// Display and LVGL setup
TFT_eSPI tft = TFT_eSPI();
static const uint16_t screenWidth = 360;
static const uint16_t screenHeight = 360;
static lv_disp_draw_buf_t draw_buf;
static lv_color_t buf[screenWidth * 10];

// WiFi and MQTT Management
WiFiManager wm;
WiFiClient espClient;
PubSubClient mqtt(espClient);

bool wifi_connected = false;
bool mqtt_connected = false;
bool ui_needs_update = true;

// Screen Management
enum Screen {
    SCREEN_ENERGY = 0,
    SCREEN_WEATHER,
    SCREEN_HOUSE_INFO,
    SCREEN_SETTINGS,
    SCREEN_COUNT  // Total number of screens
};

Screen current_screen = SCREEN_ENERGY;  // Default to Energy
const char* screen_names[] = {
    "Energy",
    "Weather", 
    "House Info",
    "Settings"
};

// Navigation state
unsigned long last_interaction = 0;
bool screen_changed = true;

// Settings menu navigation
int settings_selected_item = 0;  // Currently selected settings menu item
const int SETTINGS_MENU_ITEMS = 3;  // Number of interactive settings items
bool settings_menu_active = false;  // Whether we're navigating in settings menu

// Rotary Encoder Configuration
// Pin assignments for ESP32-C3 (from manufacturer demo code)
#define ENCODER_PIN_A 8   // GPIO8 - Rotary encoder A (ECA_PIN)
#define ENCODER_PIN_B 7   // GPIO7 - Rotary encoder B (ECB_PIN)
// No button pin - rotation only encoder

// Rotary encoder variables
volatile bool encoder_a_state = false;
volatile bool encoder_b_state = false;
volatile int encoder_position = 0;
volatile bool encoder_direction = false; // false = CCW, true = CW
volatile unsigned long last_encoder_time = 0;

// Rotary Encoder Interrupt Handlers
void IRAM_ATTR encoder_isr() {
    unsigned long now = millis();
    
    // Debounce - ignore very rapid changes
    if (now - last_encoder_time < 5) {
        return;
    }
    
    bool a_state = digitalRead(ENCODER_PIN_A);
    bool b_state = digitalRead(ENCODER_PIN_B);
    
    // Determine direction based on state changes
    if (a_state != encoder_a_state) {
        if (a_state == b_state) {
            encoder_position++;
            encoder_direction = true;  // Clockwise
        } else {
            encoder_position--;
            encoder_direction = false; // Counter-clockwise
        }
        last_encoder_time = now;
    }
    
    encoder_a_state = a_state;
    encoder_b_state = b_state;
}

// Initialize rotary encoder
void setup_rotary_encoder() {
    pinMode(ENCODER_PIN_A, INPUT_PULLUP);
    pinMode(ENCODER_PIN_B, INPUT_PULLUP);
    
    // Read initial states
    encoder_a_state = digitalRead(ENCODER_PIN_A);
    encoder_b_state = digitalRead(ENCODER_PIN_B);
    
    // Attach interrupts to both pins for better resolution
    attachInterrupt(digitalPinToInterrupt(ENCODER_PIN_A), encoder_isr, CHANGE);
    attachInterrupt(digitalPinToInterrupt(ENCODER_PIN_B), encoder_isr, CHANGE);
    
    Serial.println("Rotary encoder initialized (rotation only) on pins A:" + String(ENCODER_PIN_A) + 
                   " B:" + String(ENCODER_PIN_B));
}

// Haptic Feedback Functions
void writeHapticRegister(uint8_t reg, uint8_t value) {
    Wire.beginTransmission(DRV2605_ADDR);
    Wire.write(reg);
    Wire.write(value);
    Wire.endTransmission();
}

uint8_t readHapticRegister(uint8_t reg) {
    Wire.beginTransmission(DRV2605_ADDR);
    Wire.write(reg);
    Wire.endTransmission();
    Wire.requestFrom(DRV2605_ADDR, 1);
    return Wire.read();
}

void initHaptics() {
    Wire.begin(); // Initialize I2C
    
    // Check if DRV2605 is connected
    uint8_t status = readHapticRegister(DRV2605_STATUS);
    if (status == 0xFF) {
        Serial.println("DRV2605 not found - haptic feedback disabled");
        haptic_enabled = false;
        return;
    }
    
    // Initialize DRV2605
    writeHapticRegister(DRV2605_MODE, 0x00);      // Out of standby
    writeHapticRegister(DRV2605_RTPIN, 0x00);     // No real-time playback
    writeHapticRegister(DRV2605_LIBRARY, 1);      // Use library A (ERM)
    writeHapticRegister(DRV2605_OVERDRIVE, 0);    // No overdrive
    writeHapticRegister(DRV2605_SUSTAIN, 0);      // No sustain
    writeHapticRegister(DRV2605_BRAKE, 0);        // No brake
    
    Serial.println("DRV2605 haptic feedback initialized");
    haptic_enabled = true;
}

void playHapticEffect(HapticEffect effect) {
    if (!haptic_enabled) return;
    
    // Clear any previous sequence
    writeHapticRegister(DRV2605_WAVESEQ1, 0);
    writeHapticRegister(DRV2605_WAVESEQ2, 0);
    writeHapticRegister(DRV2605_WAVESEQ3, 0);
    writeHapticRegister(DRV2605_WAVESEQ4, 0);
    writeHapticRegister(DRV2605_WAVESEQ5, 0);
    writeHapticRegister(DRV2605_WAVESEQ6, 0);
    writeHapticRegister(DRV2605_WAVESEQ7, 0);
    writeHapticRegister(DRV2605_WAVESEQ8, 0);
    
    // Set the effect
    writeHapticRegister(DRV2605_WAVESEQ1, (uint8_t)effect);
    
    // Start playback
    writeHapticRegister(DRV2605_GO, 1);
}

// Convenience functions for different haptic feedback scenarios
void hapticClick() {
    playHapticEffect(HAPTIC_CLICK_MEDIUM);
}

void hapticScreenChange() {
    playHapticEffect(HAPTIC_CLICK_STRONG);
}

void hapticPeakReached() {
    playHapticEffect(HAPTIC_PULSE_SHARP);
}

void hapticTouch() {
    playHapticEffect(HAPTIC_CLICK_LIGHT);
}

void hapticError() {
    playHapticEffect(HAPTIC_ERROR);
}

void hapticConfirmation() {
    playHapticEffect(HAPTIC_DOUBLE_CLICK);
}

// General haptic effect trigger function
void triggerHapticEffect(HapticEffect effect) {
    playHapticEffect(effect);
}

// Handle rotary encoder navigation
void handle_rotary_navigation() {
    static int last_position = 0;
    static unsigned long last_nav_time = 0;
    unsigned long now = millis();
    
    // Check for position changes (with some hysteresis to avoid noise)
    int position_change = encoder_position - last_position;
    
    if (abs(position_change) >= 2 && (now - last_nav_time > 150)) { // Require 2 steps and debounce
        if (current_screen == SETTINGS && settings_menu_active) {
            // Navigate settings menu
            if (position_change > 0) {
                settings_selected_item = (settings_selected_item + 1) % SETTINGS_MENU_ITEMS;
            } else {
                settings_selected_item = (settings_selected_item - 1 + SETTINGS_MENU_ITEMS) % SETTINGS_MENU_ITEMS;
            }
            hapticClick();  // Light feedback for menu navigation
            screen_changed = true;  // Trigger screen update
            Serial.printf("Settings menu: item %d selected\n", settings_selected_item);
        } else {
            // Normal screen navigation
            if (position_change > 0) {
                // Clockwise - next screen
                next_screen();
                hapticScreenChange();  // Strong haptic feedback for screen change
                Serial.println("Rotary: Next screen (CW)");
            } else {
                // Counter-clockwise - previous screen
                previous_screen();
                hapticScreenChange();  // Strong haptic feedback for screen change
                Serial.println("Rotary: Previous screen (CCW)");
            }
        }
        
        last_position = encoder_position;
        last_nav_time = now;
    } else if (abs(position_change) >= 1 && (now - last_nav_time > 50)) {
        // Smaller rotations give lighter feedback (without screen change)
        hapticClick();  // Light feedback for encoder steps
        last_position = encoder_position;
        last_nav_time = now;
    }
}

// MQTT Configuration (will be set via WiFiManager)
String mqtt_server = "";
String mqtt_port = "1883";
String mqtt_username = "";
String mqtt_password = "";
String mqtt_client_id = "ESP32-Knob-";

// Energy monitoring data from EmonTX3
float energy_balance = 0.0;    // Grid import/export balance
float energy_solar = 0.0;      // Solar generation
float energy_vrms = 0.0;       // Voltage RMS
float energy_used = 0.0;       // Energy consumption
String energy_tariff = "";     // Current tariff status

// Daily peak tracking
float daily_peak_export = 0.0;  // Peak export (negative balance)
float daily_peak_import = 0.0;  // Peak import (positive balance)
unsigned long last_peak_reset = 0;  // Timestamp of last peak reset
const unsigned long PEAK_RESET_HOUR = 12;  // Reset at noon (12:00)

// Mock Data Configuration
#define ENABLE_MOCK_DATA true  // Set to false when using real MQTT data
unsigned long last_mock_update = 0;
const unsigned long MOCK_UPDATE_INTERVAL = 2000;  // Update every 2 seconds
float mock_time_offset = 0;  // Simulated time progression

// Mock data generator to simulate realistic daily energy patterns
void update_mock_data() {
    if (!ENABLE_MOCK_DATA) return;
    
    unsigned long now = millis();
    if (now - last_mock_update < MOCK_UPDATE_INTERVAL) return;
    
    // Simulate time progression (24 hours in 2 minutes for demo)
    mock_time_offset += 0.2;  // Increment time
    if (mock_time_offset > 24.0) mock_time_offset = 0;  // Reset after 24 hours
    
    // Simulate solar generation (0W at night, peak around noon)
    float solar_factor = sin((mock_time_offset - 6) * PI / 12);  // Peak at hour 12 (noon)
    if (solar_factor < 0) solar_factor = 0;  // No negative solar
    energy_solar = solar_factor * 4500 + random(-200, 200);  // 0-4500W with noise
    if (energy_solar < 0) energy_solar = 0;
    
    // Simulate house usage (higher in morning/evening, lower at night)
    float usage_base = 800;  // Base load
    float usage_morning = (mock_time_offset > 6 && mock_time_offset < 10) ? 1500 : 0;
    float usage_evening = (mock_time_offset > 17 && mock_time_offset < 22) ? 2000 : 0;
    float usage_night = (mock_time_offset < 6 || mock_time_offset > 23) ? -400 : 0;
    energy_used = usage_base + usage_morning + usage_evening + usage_night + random(-100, 300);
    if (energy_used < 100) energy_used = 100;  // Minimum usage
    
    // Calculate balance (positive = import, negative = export)
    energy_balance = energy_used - energy_solar + random(-100, 100);  // Add some noise
    
    // Simulate voltage
    energy_vrms = 240 + random(-5, 5);
    
    // Simulate tariff (peak hours 16:00-20:00)
    energy_tariff = (mock_time_offset >= 16 && mock_time_offset <= 20) ? "peak" : "standard";
    
    // Update peaks
    update_daily_peaks();
    
    // Trigger UI update with new data
    ui_needs_update = true;
    
    last_mock_update = now;
    
    // Debug output every 10 updates
    static int debug_counter = 0;
    if (++debug_counter >= 5) {
        Serial.printf("MOCK[%.1fh]: Solar=%.0fW, Usage=%.0fW, Balance=%.0fW, Tariff=%s\n", 
                     mock_time_offset, energy_solar, energy_used, energy_balance, energy_tariff.c_str());
        debug_counter = 0;
    }
}

// MQTT Topics to subscribe to (EmonTX3 + control topics)
const char* topics[] = {
    "home/knob/command",        // Device control
    "emon/emontx3/balance",     // Grid balance (import/export)
    "emon/emontx3/solar",       // Solar generation
    "emon/emontx3/vrms",        // Voltage RMS
    "emon/emontx3/used",        // Energy consumption
    "emon/emontx3/tariff"       // Tariff status
};
const int num_topics = sizeof(topics) / sizeof(topics[0]);

// Function to update daily peaks and handle reset
void update_daily_peaks() {
    // Check if we need to reset peaks (at noon each day)
    time_t now;
    struct tm timeinfo;
    time(&now);
    localtime_r(&now, &timeinfo);
    
    // Simple daily reset check (could be enhanced with RTC)
    unsigned long current_time = millis();
    
    // Reset peaks if it's been more than 24 hours since last reset
    // In a real implementation, you'd use proper time/date checking
    if (current_time - last_peak_reset > (24 * 60 * 60 * 1000)) {
        daily_peak_export = 0.0;
        daily_peak_import = 0.0;
        last_peak_reset = current_time;
        Serial.println("Daily peaks reset");
    }
    
    // Update peaks based on current balance
    if (energy_balance < 0) {
        // Exporting - track peak export (most negative value)
        if (energy_balance < daily_peak_export) {
            daily_peak_export = energy_balance;
            Serial.printf("New daily peak export: %.2f W\n", daily_peak_export);
            hapticPeakReached();  // Haptic feedback for new peak
        }
    } else if (energy_balance > 0) {
        // Importing - track peak import (most positive value)
        if (energy_balance > daily_peak_import) {
            daily_peak_import = energy_balance;
            Serial.printf("New daily peak import: %.2f W\n", daily_peak_import);
            hapticPeakReached();  // Haptic feedback for new peak
        }
    }
}

// MQTT callback function
void mqtt_callback(char* topic, byte* payload, unsigned int length) {
    // Convert payload to string
    String message = "";
    for (int i = 0; i < length; i++) {
        message += (char)payload[i];
    }
    
    Serial.printf("MQTT Received [%s]: %s\n", topic, message.c_str());
    
    // Handle different topics
    if (String(topic) == "home/knob/command") {
        // Handle knob commands
        if (message == "reset_wifi") {
            wm.resetSettings();
            ESP.restart();
        }
    } else if (String(topic) == "emon/emontx3/balance") {
        // Grid balance (positive = import, negative = export)
        energy_balance = message.toFloat();
        Serial.printf("Energy Balance: %.2f W\n", energy_balance);
        update_daily_peaks();  // Update peak tracking
        ui_needs_update = true;
    } else if (String(topic) == "emon/emontx3/solar") {
        // Solar generation
        energy_solar = message.toFloat();
        Serial.printf("Solar Generation: %.2f W\n", energy_solar);
        ui_needs_update = true;
    } else if (String(topic) == "emon/emontx3/vrms") {
        // Voltage RMS
        energy_vrms = message.toFloat();
        Serial.printf("Voltage RMS: %.2f V\n", energy_vrms);
        ui_needs_update = true;
    } else if (String(topic) == "emon/emontx3/used") {
        // Energy consumption
        energy_used = message.toFloat();
        Serial.printf("Energy Used: %.2f W\n", energy_used);
        ui_needs_update = true;
    } else if (String(topic) == "emon/emontx3/tariff") {
        // Tariff status
        energy_tariff = message;
        Serial.printf("Tariff: %s\n", energy_tariff.c_str());
        ui_needs_update = true;
    }
}

// Connect to MQTT broker
bool connect_mqtt() {
    if (mqtt_server.length() == 0) {
        Serial.println("MQTT server not configured");
        return false;
    }
    
    mqtt.setServer(mqtt_server.c_str(), mqtt_port.toInt());
    mqtt.setCallback(mqtt_callback);
    
    // Generate unique client ID
    String clientId = mqtt_client_id + String(WiFi.macAddress());
    
    Serial.printf("Connecting to MQTT broker: %s:%s\n", mqtt_server.c_str(), mqtt_port.c_str());
    
    bool connected = false;
    if (mqtt_username.length() > 0 && mqtt_password.length() > 0) {
        // Connect with credentials
        connected = mqtt.connect(clientId.c_str(), mqtt_username.c_str(), mqtt_password.c_str());
    } else {
        // Connect without credentials
        connected = mqtt.connect(clientId.c_str());
    }
    
    if (connected) {
        Serial.println("MQTT Connected!");
        mqtt_connected = true;
        
        // Subscribe to all topics
        for (int i = 0; i < num_topics; i++) {
            if (mqtt.subscribe(topics[i])) {
                Serial.printf("Subscribed to: %s\n", topics[i]);
            } else {
                Serial.printf("Failed to subscribe to: %s\n", topics[i]);
            }
        }
        
        // Publish a status message
        mqtt.publish("home/knob/status", "online");
        
    } else {
        Serial.printf("MQTT Connection failed, state: %d\n", mqtt.state());
        mqtt_connected = false;
    }
    
    return connected;
}

// WiFi status callback
void wifi_status_callback() {
    if (WiFi.status() == WL_CONNECTED) {
        wifi_connected = true;
        Serial.println("WiFi Connected!");
        Serial.print("IP: ");
        Serial.println(WiFi.localIP());
        
        // Try to connect to MQTT when WiFi connects
        if (mqtt_server.length() > 0) {
            connect_mqtt();
        }
    } else {
        wifi_connected = false;
        mqtt_connected = false;
        Serial.println("WiFi Disconnected");
    }
}

// Setup WiFi with captive portal
void setup_wifi() {
    // Reset settings for testing (comment out in production)
    // wm.resetSettings();
    
    // Set custom AP name and password for config portal
    wm.setAPStaticIPConfig(IPAddress(192,168,4,1), IPAddress(192,168,4,1), IPAddress(255,255,255,0));
    
    // Configure captive portal timeout
    wm.setConfigPortalTimeout(300); // 5 minutes timeout
    
    // Custom parameters for MQTT configuration
    WiFiManagerParameter custom_mqtt_server("mqtt_server", "MQTT Server", "", 40);
    WiFiManagerParameter custom_mqtt_port("mqtt_port", "MQTT Port", "1883", 6);
    WiFiManagerParameter custom_mqtt_username("mqtt_username", "MQTT Username", "", 32);
    WiFiManagerParameter custom_mqtt_password("mqtt_password", "MQTT Password", "", 32);
    WiFiManagerParameter custom_device_name("device", "Device Name", "ESP32-Knob", 20);
    
    // Add custom parameters to WiFi Manager
    wm.addParameter(&custom_mqtt_server);
    wm.addParameter(&custom_mqtt_port);
    wm.addParameter(&custom_mqtt_username);
    wm.addParameter(&custom_mqtt_password);
    wm.addParameter(&custom_device_name);
    
    Serial.println("Starting WiFi Manager...");
    
    // Try to connect, if it fails start config portal
    if (!wm.autoConnect("ESP32-Knob-Setup", "knob123")) {
        Serial.println("Failed to connect and hit timeout");
        // Could restart here or continue without WiFi
        ESP.restart();
    }
    
    // Connected! Save MQTT parameters
    mqtt_server = custom_mqtt_server.getValue();
    mqtt_port = custom_mqtt_port.getValue();
    mqtt_username = custom_mqtt_username.getValue();
    mqtt_password = custom_mqtt_password.getValue();
    
    // Add MAC address to client ID for uniqueness
    mqtt_client_id += String(WiFi.macAddress()).substring(9); // Last 3 pairs
    mqtt_client_id.replace(":", "");
    
    Serial.printf("MQTT Config - Server: %s, Port: %s, Username: %s\n", 
                  mqtt_server.c_str(), mqtt_port.c_str(), mqtt_username.c_str());
    
    // Connected!
    wifi_status_callback();
    
    // Set up WiFi event handlers
    WiFi.onEvent([](WiFiEvent_t event, WiFiEventInfo_t info) {
        wifi_status_callback();
    }, ARDUINO_EVENT_WIFI_STA_CONNECTED);
    
    WiFi.onEvent([](WiFiEvent_t event, WiFiEventInfo_t info) {
        wifi_status_callback();
    }, ARDUINO_EVENT_WIFI_STA_DISCONNECTED);
}

// Touch handling
bool touch_has_signal(void);
bool touch_touched(void);
bool touch_released(void);
void touch_read(lv_indev_drv_t *indev_driver, lv_indev_data_t *data);

// Display flushing
void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p)
{
    uint32_t w = (area->x2 - area->x1 + 1);
    uint32_t h = (area->y2 - area->y1 + 1);

    tft.startWrite();
    tft.setAddrWindow(area->x1, area->y1, w, h);
    tft.pushColors((uint16_t *)&color_p->full, w * h, true);
    tft.endWrite();

    lv_disp_flush_ready(disp);
}

// Touch input reading
void touch_read(lv_indev_drv_t *indev_driver, lv_indev_data_t *data)
{
    uint16_t touchX, touchY;
    bool touched = tft.getTouch(&touchX, &touchY);

    if (touched) {
        data->state = LV_INDEV_STATE_PR;
        data->point.x = touchX;
        data->point.y = touchY;
    } else {
        data->state = LV_INDEV_STATE_REL;
    }
}

// Screen creation functions
void create_energy_screen(void)
{
    // Create title with tariff indicator
    lv_obj_t *title = lv_label_create(lv_scr_act());
    String title_text = "⚡ ENERGY";
    
    // Add tariff indicator (like LED status)
    if (energy_tariff.length() > 0) {
        if (energy_tariff.toLowerCase().indexOf("low") >= 0 || 
            energy_tariff.toLowerCase().indexOf("off") >= 0 ||
            energy_tariff.toLowerCase().indexOf("night") >= 0) {
            title_text += " 🟢";  // Green for low tariff
        } else {
            title_text += " 🔴";  // Red for high tariff  
        }
    }
    
    lv_label_set_text(title, title_text.c_str());
    lv_obj_set_style_text_font(title, &lv_font_montserrat_18, 0);
    lv_obj_align(title, LV_ALIGN_TOP_MID, 0, 20);
    
    // Main balance arc - large center arc
    int arc_value = 0;
    lv_color_t arc_color;
    float max_scale_export = 4000.0;  // 4kW export max
    float max_scale_import = 8000.0;  // 8kW import max
    
    if (energy_balance < 0) {
        // Exporting (excess solar) - scale to 4000W max
        float abs_balance = abs(energy_balance);
        arc_value = (int)((abs_balance / max_scale_export) * 100);
        if (arc_value > 100) arc_value = 100;
        
        // Color based on solar generation
        if (energy_solar > 1500) {
            arc_color = lv_palette_main(LV_PALETTE_GREEN);  // Good solar
        } else {
            arc_color = lv_palette_main(LV_PALETTE_ORANGE); // Low solar
        }
    } else if (energy_balance > 0) {
        // Importing - scale to 8000W max
        arc_value = (int)((energy_balance / max_scale_import) * 100);
        if (arc_value > 100) arc_value = 100;
        arc_color = lv_palette_main(LV_PALETTE_RED);        // Importing
    } else {
        // Balanced
        arc_value = 0;
        arc_color = lv_palette_main(LV_PALETTE_GREY);       // Neutral
    }
    
    // Create main balance arc
    lv_obj_t *balance_arc = lv_arc_create(lv_scr_act());
    lv_obj_set_size(balance_arc, 200, 200);
    lv_obj_center(balance_arc);
    lv_arc_set_rotation(balance_arc, 270);
    lv_arc_set_bg_angles(balance_arc, 0, 360);
    lv_arc_set_value(balance_arc, arc_value);
    lv_obj_remove_style(balance_arc, NULL, LV_PART_KNOB);
    lv_obj_set_style_arc_color(balance_arc, arc_color, LV_PART_INDICATOR);
    
    // Add peak dots on the balance arc
    // Calculate peak positions as angles (0-360 degrees)
    if (daily_peak_export < 0) {
        // Export peak dot (green)
        float export_angle = (abs(daily_peak_export) / max_scale_export) * 360;
        if (export_angle > 360) export_angle = 360;
        
        lv_obj_t *export_dot = lv_obj_create(lv_scr_act());
        lv_obj_set_size(export_dot, 8, 8);
        lv_obj_set_style_bg_color(export_dot, lv_palette_main(LV_PALETTE_GREEN), 0);
        lv_obj_set_style_border_width(export_dot, 2, 0);
        lv_obj_set_style_border_color(export_dot, lv_color_white(), 0);
        lv_obj_set_style_radius(export_dot, LV_RADIUS_CIRCLE, 0);
        
        // Position dot on arc circumference
        float rad = (export_angle - 90) * M_PI / 180.0;  // Convert to radians, offset by 90°
        int dot_x = 180 + (int)(90 * cos(rad));  // 90 = arc radius - dot radius
        int dot_y = 180 + (int)(90 * sin(rad));
        lv_obj_set_pos(export_dot, dot_x - 4, dot_y - 4);  // Center the dot
    }
    
    if (daily_peak_import > 0) {
        // Import peak dot (red)
        float import_angle = (daily_peak_import / max_scale_import) * 360;
        if (import_angle > 360) import_angle = 360;
        
        lv_obj_t *import_dot = lv_obj_create(lv_scr_act());
        lv_obj_set_size(import_dot, 8, 8);
        lv_obj_set_style_bg_color(import_dot, lv_palette_main(LV_PALETTE_RED), 0);
        lv_obj_set_style_border_width(import_dot, 2, 0);
        lv_obj_set_style_border_color(import_dot, lv_color_white(), 0);
        lv_obj_set_style_radius(import_dot, LV_RADIUS_CIRCLE, 0);
        
        // Position dot on arc circumference
        float rad = (import_angle - 90) * M_PI / 180.0;  // Convert to radians, offset by 90°
        int dot_x = 180 + (int)(90 * cos(rad));  // 90 = arc radius - dot radius
        int dot_y = 180 + (int)(90 * sin(rad));
        lv_obj_set_pos(import_dot, dot_x - 4, dot_y - 4);  // Center the dot
    }
    
    // Main balance display (center of main arc)
    lv_obj_t *balance_label = lv_label_create(lv_scr_act());
    String balance_text = "";
    
    if (energy_balance < 0) {
        balance_text = "EXPORT\n" + String(abs(energy_balance), 0) + "W";
    } else if (energy_balance > 0) {
        balance_text = "IMPORT\n" + String(energy_balance, 0) + "W";
    } else {
        balance_text = "BALANCED\n0W";
    }
    
    lv_label_set_text(balance_label, balance_text.c_str());
    lv_obj_set_style_text_font(balance_label, &lv_font_montserrat_14, 0);
    lv_obj_set_style_text_align(balance_label, LV_TEXT_ALIGN_CENTER, 0);
    lv_obj_center(balance_label);
    
    // Left mini arc - Solar Generation (0-5000W scale)
    if (energy_solar > 0) {
        lv_obj_t *solar_arc = lv_arc_create(lv_scr_act());
        lv_obj_set_size(solar_arc, 60, 60);
        lv_obj_align(solar_arc, LV_ALIGN_LEFT_MID, 20, 0);
        lv_arc_set_rotation(solar_arc, 270);
        lv_arc_set_bg_angles(solar_arc, 0, 180);  // Half circle
        int solar_value = (int)((energy_solar / 5000.0) * 100);
        if (solar_value > 100) solar_value = 100;
        lv_arc_set_value(solar_arc, solar_value);
        lv_obj_remove_style(solar_arc, NULL, LV_PART_KNOB);
        lv_obj_set_style_arc_color(solar_arc, lv_palette_main(LV_PALETTE_YELLOW), LV_PART_INDICATOR);
        
        // Solar label
        lv_obj_t *solar_label = lv_label_create(lv_scr_act());
        String solar_text = "☀️\n" + String(energy_solar, 0);
        lv_label_set_text(solar_label, solar_text.c_str());
        lv_obj_set_style_text_font(solar_label, &lv_font_montserrat_10, 0);
        lv_obj_set_style_text_align(solar_label, LV_TEXT_ALIGN_CENTER, 0);
        lv_obj_align_to(solar_label, solar_arc, LV_ALIGN_CENTER, 0, 0);
    }
    
    // Right mini arc - House Usage (0-8000W scale)
    if (energy_used > 0) {
        lv_obj_t *usage_arc = lv_arc_create(lv_scr_act());
        lv_obj_set_size(usage_arc, 60, 60);
        lv_obj_align(usage_arc, LV_ALIGN_RIGHT_MID, -20, 0);
        lv_arc_set_rotation(usage_arc, 270);
        lv_arc_set_bg_angles(usage_arc, 0, 180);  // Half circle
        int usage_value = (int)((energy_used / 8000.0) * 100);
        if (usage_value > 100) usage_value = 100;
        lv_arc_set_value(usage_arc, usage_value);
        lv_obj_remove_style(usage_arc, NULL, LV_PART_KNOB);
        lv_obj_set_style_arc_color(usage_arc, lv_palette_main(LV_PALETTE_BLUE), LV_PART_INDICATOR);
        
        // Usage label
        lv_obj_t *usage_label = lv_label_create(lv_scr_act());
        String usage_text = "🏠\n" + String(energy_used, 0);
        lv_label_set_text(usage_label, usage_text.c_str());
        lv_obj_set_style_text_font(usage_label, &lv_font_montserrat_10, 0);
        lv_obj_set_style_text_align(usage_label, LV_TEXT_ALIGN_CENTER, 0);
        lv_obj_align_to(usage_label, usage_arc, LV_ALIGN_CENTER, 0, 0);
    }
    
    // Small voltage display and connection status (bottom center)
    lv_obj_t *status = lv_label_create(lv_scr_act());
    String status_text = "";
    if (mqtt_connected) {
        status_text = "📡 EmonTX3";
        if (energy_vrms > 0) {
            status_text += " | " + String(energy_vrms, 0) + "V";
        }
    } else {
        status_text = "📡 Offline";
    }
    lv_label_set_text(status, status_text.c_str());
    lv_obj_set_style_text_font(status, &lv_font_montserrat_10, 0);
    lv_obj_align(status, LV_ALIGN_BOTTOM_MID, 0, -10);
}

void create_weather_screen(void)
{
    // Create title
    lv_obj_t *title = lv_label_create(lv_scr_act());
    lv_label_set_text(title, "🌤️ WEATHER");
    lv_obj_set_style_text_font(title, &lv_font_montserrat_18, 0);
    lv_obj_align(title, LV_ALIGN_TOP_MID, 0, 20);
    
    // Temperature arc
    lv_obj_t *arc = lv_arc_create(lv_scr_act());
    lv_obj_set_size(arc, 180, 180);
    lv_obj_center(arc);
    lv_arc_set_rotation(arc, 270);
    lv_arc_set_bg_angles(arc, 0, 360);
    lv_arc_set_value(arc, 72);  // Example: 72% of temp range
    lv_obj_remove_style(arc, NULL, LV_PART_KNOB);
    
    // Weather info
    lv_obj_t *weather_label = lv_label_create(lv_scr_act());
    lv_label_set_text(weather_label, "22°C\nPartly Cloudy\n45% Humidity");
    lv_obj_set_style_text_font(weather_label, &lv_font_montserrat_14, 0);
    lv_obj_set_style_text_align(weather_label, LV_TEXT_ALIGN_CENTER, 0);
    lv_obj_center(weather_label);
    
    // Data source
    lv_obj_t *source = lv_label_create(lv_scr_act());
    String source_text = mqtt_connected ? "📡 Live Weather" : "📡 Offline";
    lv_label_set_text(source, source_text.c_str());
    lv_obj_align(source, LV_ALIGN_BOTTOM_MID, 0, -10);
    
    // Arc color for temperature
    lv_color_t arc_color = lv_palette_main(LV_PALETTE_ORANGE);
    lv_obj_set_style_arc_color(arc, arc_color, LV_PART_INDICATOR);
}

void create_house_info_screen(void)
{
    // Create title
    lv_obj_t *title = lv_label_create(lv_scr_act());
    lv_label_set_text(title, "🏠 HOUSE INFO");
    lv_obj_set_style_text_font(title, &lv_font_montserrat_18, 0);
    lv_obj_align(title, LV_ALIGN_TOP_MID, 0, 20);
    
    // Connection status arc
    lv_obj_t *arc = lv_arc_create(lv_scr_act());
    lv_obj_set_size(arc, 180, 180);
    lv_obj_center(arc);
    lv_arc_set_rotation(arc, 270);
    lv_arc_set_bg_angles(arc, 0, 360);
    int connection_pct = (wifi_connected ? 50 : 0) + (mqtt_connected ? 50 : 0);
    lv_arc_set_value(arc, connection_pct);
    lv_obj_remove_style(arc, NULL, LV_PART_KNOB);
    
    // House systems info
    lv_obj_t *info_label = lv_label_create(lv_scr_act());
    String info_text = "WiFi: ";
    info_text += wifi_connected ? "✅" : "❌";
    info_text += "\nMQTT: ";
    info_text += mqtt_connected ? "✅" : "❌";
    if (wifi_connected) {
        info_text += "\nIP: " + WiFi.localIP().toString();
    }
    lv_label_set_text(info_label, info_text.c_str());
    lv_obj_set_style_text_font(info_label, &lv_font_montserrat_14, 0);
    lv_obj_set_style_text_align(info_label, LV_TEXT_ALIGN_CENTER, 0);
    lv_obj_center(info_label);
    
    // Device info
    lv_obj_t *device = lv_label_create(lv_scr_act());
    lv_label_set_text(device, "ESP32-C3 Knob");
    lv_obj_align(device, LV_ALIGN_BOTTOM_MID, 0, -10);
    
    // Arc color based on connection
    lv_color_t arc_color;
    if (wifi_connected && mqtt_connected) {
        arc_color = lv_palette_main(LV_PALETTE_GREEN);
    } else if (wifi_connected) {
        arc_color = lv_palette_main(LV_PALETTE_ORANGE);
    } else {
        arc_color = lv_palette_main(LV_PALETTE_RED);
    }
    lv_obj_set_style_arc_color(arc, arc_color, LV_PART_INDICATOR);
}

void create_settings_screen(void)
{
    // Create title
    lv_obj_t *title = lv_label_create(lv_scr_act());
    lv_label_set_text(title, "⚙️ SETTINGS");
    lv_obj_set_style_text_font(title, &lv_font_montserrat_18, 0);
    lv_obj_align(title, LV_ALIGN_TOP_MID, 0, 20);
    
    // Settings menu with selection indicators
    lv_obj_t *menu_label = lv_label_create(lv_scr_act());
    String settings_text = "";
    
    // Mock Data setting (item 0)
    settings_text += (settings_selected_item == 0) ? "▶ " : "  ";
    settings_text += "Mock Data: ";
    settings_text += ENABLE_MOCK_DATA ? "ON 🟢" : "OFF 🔴";
    settings_text += "\n";
    
    // Haptic Feedback setting (item 1)
    settings_text += (settings_selected_item == 1) ? "▶ " : "  ";
    settings_text += "Haptic Feedback: ";
    settings_text += haptic_enabled ? "ON 🟢" : "OFF 🔴";
    settings_text += "\n";
    
    // WiFi Reset setting (item 2)
    settings_text += (settings_selected_item == 2) ? "▶ " : "  ";
    settings_text += "Reset WiFi\n";
    
    // Non-interactive items
    settings_text += "  Brightness: 80%\n";
    settings_text += "  Factory Reset\n";
    settings_text += "  Display Info";
    
    lv_label_set_text(menu_label, settings_text.c_str());
    lv_obj_set_style_text_font(menu_label, &lv_font_montserrat_14, 0);
    lv_obj_set_style_text_align(menu_label, LV_TEXT_ALIGN_LEFT, 0);
    lv_obj_center(menu_label);
    
    // Instructions
    lv_obj_t *instructions = lv_label_create(lv_scr_act());
    String inst_text = "Rotate: Navigate  Touch: Select/Toggle";
    if (ENABLE_MOCK_DATA) {
        inst_text += "\n\n🎯 DEMO MODE ACTIVE";
    }
    if (haptic_enabled) {
        inst_text += "\n🎛️ Haptic feedback enabled";
    }
    lv_label_set_text(instructions, inst_text.c_str());
    lv_obj_align(instructions, LV_ALIGN_BOTTOM_MID, 0, -10);
}

// Navigation functions
void switch_to_screen(Screen new_screen)
{
    if (new_screen != current_screen) {
        // Reset settings menu when leaving settings screen
        if (current_screen == SETTINGS) {
            settings_menu_active = false;
            settings_selected_item = 0;
        }
        
        current_screen = new_screen;
        screen_changed = true;
        ui_needs_update = true;
        last_interaction = millis();
        
        Serial.printf("Switched to screen: %s\n", screen_names[current_screen]);
    }
}

void next_screen()
{
    Screen next = (Screen)((current_screen + 1) % SCREEN_COUNT);
    switch_to_screen(next);
}

void previous_screen()
{
    Screen prev = (Screen)((current_screen - 1 + SCREEN_COUNT) % SCREEN_COUNT);
    switch_to_screen(prev);
}

// Update current screen
void update_current_screen(void)
{
    // Clear screen
    lv_obj_clean(lv_scr_act());
    
    // Create the appropriate screen
    switch (current_screen) {
        case SCREEN_ENERGY:
            create_energy_screen();
            break;
        case SCREEN_WEATHER:
            create_weather_screen();
            break;
        case SCREEN_HOUSE_INFO:
            create_house_info_screen();
            break;
        case SCREEN_SETTINGS:
            create_settings_screen();
            break;
    }
    
    // Add screen indicator at top
    lv_obj_t *indicator = lv_label_create(lv_scr_act());
    String indicator_text = String(current_screen + 1) + "/" + String(SCREEN_COUNT) + " - Rotate to change";
    lv_label_set_text(indicator, indicator_text.c_str());
    lv_obj_set_style_text_font(indicator, &lv_font_montserrat_10, 0);
    lv_obj_align(indicator, LV_ALIGN_TOP_MID, 0, 5);
}

// Legacy function - now calls update_current_screen
void create_demo_ui(void)
{
    update_current_screen();
}

void setup()
{
    Serial.begin(115200);
    Serial.println("Starting ESP32-C3 Knob Display...");

    // Setup WiFi first
    setup_wifi();

    // Initialize display
    tft.init();
    tft.setRotation(0);
    tft.fillScreen(TFT_BLACK);

    // Initialize touch calibration
    uint16_t calData[5] = {275, 3620, 264, 3532, 1};
    tft.setTouch(calData);

    // Initialize LVGL
    lv_init();

    // Initialize display buffer
    lv_disp_draw_buf_init(&draw_buf, buf, NULL, screenWidth * 10);

    // Initialize display driver
    static lv_disp_drv_t disp_drv;
    lv_disp_drv_init(&disp_drv);
    disp_drv.hor_res = screenWidth;
    disp_drv.ver_res = screenHeight;
    disp_drv.flush_cb = my_disp_flush;
    disp_drv.draw_buf = &draw_buf;
    lv_disp_drv_register(&disp_drv);

    // Initialize input device driver
    static lv_indev_drv_t indev_drv;
    lv_indev_drv_init(&indev_drv);
    indev_drv.type = LV_INDEV_TYPE_POINTER;
    indev_drv.read_cb = touch_read;
    lv_indev_drv_register(&indev_drv);

    // Initialize rotary encoder
    setup_rotary_encoder();

    // Initialize haptic feedback
    initHaptics();
    
    // Play startup confirmation
    if (haptic_enabled) {
        hapticConfirmation();
    }

    // Create the demo UI (will be replaced by SquareLine Studio)
    create_demo_ui();
    
    // When using SquareLine Studio, replace the above with:
    // ui_init();  // This will be generated by SquareLine Studio

    Serial.println("Setup complete!");
}

void loop()
{
    // Update mock data for testing (disable when using real MQTT)
    update_mock_data();
    
    // Handle LVGL tasks
    lv_timer_handler();
    
    // Handle WiFiManager portal
    wifiManager.process();
    
    // Handle rotary encoder navigation
    handle_rotary_navigation();
    
    // Touch screen navigation (primary button replacement)
    // Touch screen to enter/confirm actions
    static bool touch_was_pressed = false;
    static unsigned long last_touch_time = 0;
    
    // Check for touch events
    lv_indev_t * indev = lv_indev_get_next(NULL);
    if (indev != NULL) {
        lv_indev_data_t data;
        lv_indev_read(indev, &data);
        
        bool touch_pressed = (data.state == LV_INDEV_STATE_PR);
        unsigned long now = millis();
        
        // Touch acts as "button press" - could be used for settings or actions
        if (touch_pressed && !touch_was_pressed && (now - last_touch_time > 400)) {
            if (current_screen == SETTINGS) {
                if (!settings_menu_active) {
                    // First touch on settings screen enters menu mode
                    settings_menu_active = true;
                    settings_selected_item = 0;
                    triggerHapticEffect(HAPTIC_CLICK_MEDIUM);
                    screen_changed = true;
                    Serial.println("Settings menu activated");
                } else {
                    // Touch selects/toggles current menu item
                    switch (settings_selected_item) {
                        case 0: // Mock Data toggle (not implemented in this demo)
                            Serial.println("Mock Data toggle selected (not implemented)");
                            triggerHapticEffect(HAPTIC_CLICK_LIGHT);
                            break;
                        case 1: // Haptic Feedback toggle
                            haptic_enabled = !haptic_enabled;
                            triggerHapticEffect(HAPTIC_DOUBLE_CLICK);
                            screen_changed = true;
                            Serial.printf("Haptic feedback %s\n", haptic_enabled ? "enabled" : "disabled");
                            break;
                        case 2: // WiFi Reset
                            Serial.println("WiFi Reset selected (not implemented)");
                            triggerHapticEffect(HAPTIC_ERROR);
                            break;
                    }
                }
            } else {
                // Normal screen navigation
                triggerHapticEffect(HAPTIC_SCREEN_CHANGE);
                next_screen();
            }
            last_touch_time = now;
        }
        touch_was_pressed = touch_pressed;
    }
    
    // Update WiFi connection status
    bool current_wifi_status = WiFi.status() == WL_CONNECTED;
    if (current_wifi_status != wifi_connected) {
        wifi_connected = current_wifi_status;
        Serial.printf("WiFi status changed: %s\n", wifi_connected ? "Connected" : "Disconnected");
        ui_needs_update = true;
        
        // If WiFi disconnected, mark MQTT as disconnected too
        if (!wifi_connected && mqtt_connected) {
            mqtt_connected = false;
            ui_needs_update = true;
        }
    }
    
    // Handle MQTT connection if WiFi is connected (skip in mock mode)
    if (wifi_connected && !ENABLE_MOCK_DATA) {
        // Check if MQTT client is connected
        bool current_mqtt_status = mqtt.connected();
        if (current_mqtt_status != mqtt_connected) {
            mqtt_connected = current_mqtt_status;
            Serial.printf("MQTT status changed: %s\n", mqtt_connected ? "Connected" : "Disconnected");
            ui_needs_update = true;
        }
        
        // Attempt to connect/reconnect to MQTT if not connected
        if (!mqtt_connected) {
            connect_mqtt();
        }
        
        // Process MQTT messages (skip in mock mode)
        if (!ENABLE_MOCK_DATA) {
            mqtt.loop();
        }
    } else if (ENABLE_MOCK_DATA) {
        // In mock mode, simulate connected status for UI
        if (!mqtt_connected) {
            mqtt_connected = true;
            ui_needs_update = true;
            Serial.println("MOCK: Simulating MQTT connected");
        }
    }
    
    // Update UI if needed (screen changed or connection status changed)
    if (ui_needs_update || screen_changed) {
        ui_needs_update = false;
        screen_changed = false;
        update_current_screen();
    }
    
    delay(10);  // Small delay to prevent watchdog issues
}
